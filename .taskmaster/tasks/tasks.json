{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Monorepo 및 기반 인프라 설정",
        "description": "Turborepo를 사용한 모노레포 구조 설정 및 개발 환경 구축",
        "details": "1. Turborepo 초기화: `npx create-turbo@latest qr-smart-order`\n2. 패키지 구조 설정:\n   - apps/web (Next.js 14)\n   - apps/api (Nest.js)\n   - packages/shared-types (Zod 스키마)\n   - packages/ui (shadcn/ui)\n   - packages/tsconfig\n3. 루트 package.json에 워크스페이스 설정\n4. turbo.json 파이프라인 구성 (dev, build, lint, test)\n5. ESLint, Prettier 설정\n6. TypeScript 설정 공유\n7. Git 초기화 및 .gitignore 설정",
        "testStrategy": "turbo dev 실행 시 모든 앱이 정상 실행되는지 확인, 패키지 간 타입 공유가 정상 작동하는지 검증",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Turborepo 초기화 및 기본 패키지 구조 설정",
            "description": "Turborepo 프로젝트 생성 및 apps, packages 디렉토리 구조 설정",
            "dependencies": [],
            "details": "1. `npx create-turbo@latest qr-smart-order` 실행\n2. apps 디렉토리에 web, api 폴더 생성\n3. packages 디렉토리에 shared-types, ui, tsconfig 폴더 생성\n4. 각 패키지별 기본 package.json 파일 생성\n5. 루트 package.json에 워크스페이스 설정 추가",
            "status": "done",
            "testStrategy": "",
            "updatedAt": "2026-01-08T13:07:59.959Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Next.js 및 Nest.js 애플리케이션 설정",
            "description": "웹 프론트엔드와 API 백엔드 애플리케이션 초기 설정",
            "dependencies": [
              "1.1"
            ],
            "details": "1. apps/web에 Next.js 14 프로젝트 설정\n2. apps/api에 Nest.js 프로젝트 설정\n3. 각 앱의 package.json 의존성 설정\n4. 기본 라우팅 및 컨트롤러 구조 생성\n5. 앱 간 포트 설정 (web: 3000, api: 3001)",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T14:04:26.102Z"
          },
          {
            "id": 3,
            "title": "공유 패키지 및 개발 도구 설정",
            "description": "TypeScript 설정, UI 컴포넌트, 린팅 도구 등 공유 패키지 구성",
            "dependencies": [
              "1.1"
            ],
            "details": "1. packages/tsconfig에 공통 TypeScript 설정 파일 생성\n2. packages/ui에 shadcn/ui 컴포넌트 라이브러리 설정\n3. packages/shared-types에 기본 타입 정의 파일 생성\n4. ESLint, Prettier 설정 파일 생성 및 공유\n5. 각 패키지 간 의존성 연결 설정",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-13T02:01:41.672Z"
          },
          {
            "id": 4,
            "title": "Turbo 파이프라인 구성 및 Git 설정",
            "description": "빌드 파이프라인 설정 및 버전 관리 시스템 초기화",
            "dependencies": [
              "1.2",
              "1.3"
            ],
            "details": "1. turbo.json 파일에 dev, build, lint, test 파이프라인 구성\n2. 각 패키지별 스크립트 명령어 정의\n3. Git 저장소 초기화 및 .gitignore 설정\n4. 루트 레벨 npm scripts 설정 (turbo dev, turbo build 등)\n5. 전체 모노레포 구조 검증 및 테스트 실행",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2026-01-13T03:28:52.179Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Turborepo 모노레포 설정을 위한 세부 작업들을 단계별로 분리하여 각각의 패키지 설정, 개발 도구 구성, 워크스페이스 연결을 독립적으로 수행할 수 있도록 세분화해주세요.",
        "updatedAt": "2026-01-13T03:28:52.179Z"
      },
      {
        "id": "2",
        "title": "데이터베이스 스키마 설계 및 Supabase 설정",
        "description": "PostgreSQL 데이터베이스 스키마 정의 및 Supabase 프로젝트 설정",
        "details": "1. Supabase 프로젝트 생성\n2. Prisma 설치 및 설정:\n   ```prisma\n   model Menu {\n     id String @id @default(uuid())\n     name String\n     price Int\n     imageUrl String?\n     isSoldOut Boolean @default(false)\n     createdAt DateTime @default(now())\n   }\n   \n   model Order {\n     id String @id @default(uuid())\n     orderNo Int @default(autoincrement())\n     status OrderStatus @default(PENDING)\n     items Json\n     totalPrice Int\n     createdAt DateTime @default(now())\n     updatedAt DateTime @updatedAt\n   }\n   \n   enum OrderStatus {\n     PENDING\n     COOKING\n     READY\n     COMPLETED\n   }\n   ```\n3. 마이그레이션 실행\n4. 시드 데이터 생성 (샘플 메뉴)\n5. 환경변수 설정 (.env)",
        "testStrategy": "Prisma Studio로 테이블 생성 확인, 시드 데이터 정상 삽입 검증, 기본 CRUD 쿼리 테스트",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Supabase 프로젝트 생성 및 초기 설정",
            "description": "Supabase 계정 생성 및 새 프로젝트 설정, 데이터베이스 접근 권한 구성",
            "dependencies": [],
            "details": "1. Supabase 계정 생성 또는 로그인\n2. 새 프로젝트 생성 및 이름 설정\n3. 데이터베이스 비밀번호 설정 및 저장\n4. 프로젝트 URL 및 API 키 확보\n5. CORS 설정 구성\n6. 데이터베이스 접근 정책 설정",
            "status": "done",
            "testStrategy": "Supabase 대시보드 접속 확인, API 키를 사용한 기본 연결 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-13T03:58:48.109Z"
          },
          {
            "id": 2,
            "title": "Prisma 설치 및 기본 설정",
            "description": "프로젝트에 Prisma 설치 및 초기 설정 구성, 데이터베이스 연결 설정",
            "dependencies": [
              1
            ],
            "details": "1. Prisma CLI 및 클라이언트 설치: `npm install prisma @prisma/client`\n2. Prisma 초기화: `npx prisma init`\n3. .env 파일에 DATABASE_URL 설정 (Supabase 연결 문자열 사용)\n4. Prisma 스키마 파일 기본 구조 설정\n5. Prisma VS Code 확장 프로그램 설치 (선택사항)",
            "status": "done",
            "testStrategy": "Prisma CLI 명령어 실행 확인, 데이터베이스 연결 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-14T02:09:01.086Z"
          },
          {
            "id": 3,
            "title": "Menu 모델 스키마 정의 및 마이그레이션",
            "description": "Prisma 스키마에 Menu 모델 정의 및 데이터베이스 마이그레이션 실행",
            "dependencies": [
              2
            ],
            "details": "1. schema.prisma 파일에 Menu 모델 정의:\n```prisma\nmodel Menu {\n  id String @id @default(uuid())\n  name String\n  price Int\n  imageUrl String?\n  isSoldOut Boolean @default(false)\n  createdAt DateTime @default(now())\n}\n```\n2. 마이그레이션 생성: `npx prisma migrate dev --name add_menu_model`\n3. 마이그레이션 적용 확인\n4. Prisma 클라이언트 생성",
            "status": "done",
            "testStrategy": "Prisma Studio에서 Menu 테이블 생성 확인, 테이블 구조 검증",
            "parentId": "undefined",
            "updatedAt": "2026-01-14T04:25:37.866Z"
          },
          {
            "id": 4,
            "title": "Order 모델 스키마 정의 및 마이그레이션",
            "description": "Prisma 스키마에 Order 모델 및 OrderStatus enum 정의, 데이터베이스 마이그레이션 실행",
            "dependencies": [
              2
            ],
            "details": "1. schema.prisma 파일에 OrderStatus enum 정의:\n```prisma\nenum OrderStatus {\n  PENDING\n  COOKING\n  READY\n  COMPLETED\n}\n```\n2. Order 모델 정의:\n```prisma\nmodel Order {\n  id String @id @default(uuid())\n  orderNo Int @default(autoincrement())\n  status OrderStatus @default(PENDING)\n  items Json\n  totalPrice Int\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n}\n```\n3. 마이그레이션 생성: `npx prisma migrate dev --name add_order_model`\n4. 마이그레이션 적용 확인",
            "status": "done",
            "testStrategy": "Prisma Studio에서 Order 테이블 및 OrderStatus enum 생성 확인, 테이블 구조 검증",
            "parentId": "undefined",
            "updatedAt": "2026-01-14T04:27:03.204Z"
          },
          {
            "id": 5,
            "title": "Menu 시드 데이터 생성",
            "description": "샘플 메뉴 데이터를 생성하여 데이터베이스에 초기 데이터 삽입",
            "dependencies": [
              3
            ],
            "details": "1. prisma/seed.ts 파일 생성\n2. 샘플 메뉴 데이터 정의:\n```typescript\nconst menuData = [\n  { name: '아메리카노', price: 4500, imageUrl: '/images/americano.jpg' },\n  { name: '카페라떼', price: 5000, imageUrl: '/images/latte.jpg' },\n  { name: '카푸치노', price: 5000, imageUrl: '/images/cappuccino.jpg' },\n  { name: '바닐라라떼', price: 5500, imageUrl: '/images/vanilla_latte.jpg' },\n  { name: '카라멜마끼아또', price: 5500, imageUrl: '/images/caramel_macchiato.jpg' }\n];\n```\n3. 시드 스크립트 구현\n4. package.json에 시드 명령어 추가\n5. 시드 실행: `npx prisma db seed`",
            "status": "done",
            "testStrategy": "Prisma Studio에서 시드 데이터 확인, 데이터 개수 및 내용 검증",
            "parentId": "undefined",
            "updatedAt": "2026-01-14T04:29:06.103Z"
          },
          {
            "id": 6,
            "title": "환경변수 설정 및 관리",
            "description": "프로젝트에 필요한 환경변수 설정 및 관리 방법 구성",
            "dependencies": [
              1,
              2
            ],
            "details": "1. .env 파일 구성:\n```\nDATABASE_URL=\"postgresql://postgres:[YOUR-PASSWORD]@db.[YOUR-PROJECT-ID].supabase.co:5432/postgres\"\nNEXT_PUBLIC_SUPABASE_URL=\"https://[YOUR-PROJECT-ID].supabase.co\"\nNEXT_PUBLIC_SUPABASE_ANON_KEY=\"[YOUR-ANON-KEY]\"\n```\n2. .env.example 파일 생성 (민감 정보 제외)\n3. .gitignore에 .env 추가\n4. 환경변수 로드 유틸리티 함수 작성\n5. 개발/테스트/프로덕션 환경별 환경변수 관리 전략 수립",
            "status": "done",
            "testStrategy": "환경변수 로드 테스트, 애플리케이션에서 환경변수 접근 확인",
            "parentId": "undefined",
            "updatedAt": "2026-01-14T04:37:28.904Z"
          },
          {
            "id": 7,
            "title": "Prisma 클라이언트 설정 및 데이터베이스 연결 테스트",
            "description": "Prisma 클라이언트를 설정하고 데이터베이스 연결 및 기본 CRUD 작업 테스트",
            "dependencies": [
              3,
              4,
              5,
              6
            ],
            "details": "1. lib/prisma.ts 파일 생성:\n```typescript\nimport { PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient();\n\nexport default prisma;\n```\n2. 기본 CRUD 작업 테스트 스크립트 작성\n3. 데이터베이스 연결 테스트\n4. 트랜잭션 테스트\n5. 에러 처리 로직 구현",
            "status": "done",
            "testStrategy": "기본 CRUD 작업 테스트, 트랜잭션 롤백 테스트, 에러 처리 검증",
            "parentId": "undefined",
            "updatedAt": "2026-01-14T04:41:28.937Z"
          },
          {
            "id": 8,
            "title": "Supabase와 Prisma 통합 검증",
            "description": "Supabase와 Prisma가 올바르게 통합되어 작동하는지 종합적으로 검증",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6,
              7
            ],
            "details": "1. 전체 데이터베이스 스키마 검증\n2. Supabase 대시보드에서 테이블 확인\n3. Prisma Studio에서 데이터 조회 및 수정\n4. 간단한 API 엔드포인트 구현하여 데이터 접근 테스트\n5. 성능 테스트 (기본 쿼리 실행 시간 측정)\n6. 문제점 식별 및 해결\n7. 최종 문서화",
            "status": "done",
            "testStrategy": "종합적인 CRUD 작업 테스트, Supabase 대시보드와 Prisma Studio 간 데이터 일관성 검증, API 엔드포인트를 통한 데이터 접근 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-14T06:14:29.347Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "데이터베이스 설정을 Supabase 프로젝트 생성, Prisma 스키마 정의 및 마이그레이션, 시드 데이터 생성으로 나누어 각각을 독립적으로 검증할 수 있도록 세분화해주세요.",
        "updatedAt": "2026-01-14T06:14:29.347Z"
      },
      {
        "id": "3",
        "title": "공유 타입 정의 및 Zod 스키마 구현",
        "description": "프론트엔드와 백엔드에서 공유할 타입 정의 및 검증 스키마 작성",
        "details": "packages/shared-types에 다음 스키마 정의:\n1. MenuSchema:\n   ```typescript\n   export const MenuSchema = z.object({\n     id: z.string().uuid(),\n     name: z.string().min(1),\n     price: z.number().positive(),\n     imageUrl: z.string().url().optional(),\n     isSoldOut: z.boolean().default(false)\n   });\n   ```\n2. OrderSchema:\n   ```typescript\n   export const OrderItemSchema = z.object({\n     menuId: z.string().uuid(),\n     name: z.string(),\n     price: z.number().positive(),\n     count: z.number().positive()\n   });\n   \n   export const OrderSchema = z.object({\n     id: z.string().uuid(),\n     orderNo: z.number().positive(),\n     status: z.enum(['PENDING', 'COOKING', 'READY', 'COMPLETED']),\n     items: z.array(OrderItemSchema),\n     totalPrice: z.number().positive()\n   });\n   ```\n3. API 요청/응답 스키마\n4. WebSocket 이벤트 스키마\n5. 타입 추론 및 export",
        "testStrategy": "각 스키마의 유효성 검증 테스트 작성, 잘못된 데이터 입력 시 에러 발생 확인",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "기본 엔티티 스키마 구현 (Menu, Order)",
            "description": "이미 정의된 MenuSchema와 OrderSchema를 packages/shared-types에 구현하고 필요한 타입 추론 설정",
            "dependencies": [],
            "details": "packages/shared-types 디렉토리에 기존에 정의된 MenuSchema와 OrderSchema를 구현합니다. z.infer를 사용하여 타입 추론을 설정하고, 각 스키마에 대한 타입 정의를 export합니다. 또한 필요한 enum 타입(예: OrderStatus)도 함께 정의합니다.",
            "status": "done",
            "testStrategy": "각 스키마의 유효성 검증 테스트 작성, 잘못된 데이터 입력 시 에러 발생 확인",
            "parentId": "undefined",
            "updatedAt": "2026-01-14T12:38:10.116Z"
          },
          {
            "id": 2,
            "title": "API 요청 스키마 구현",
            "description": "API 요청에 필요한 스키마 정의 및 타입 추론 설정",
            "dependencies": [
              1
            ],
            "details": "메뉴 생성, 조회, 수정, 삭제 및 주문 생성, 조회, 상태 변경 등의 API 요청에 필요한 스키마를 정의합니다. 각 API 엔드포인트별로 필요한 요청 파라미터와 바디 스키마를 구현하고, 타입 추론을 설정합니다.",
            "status": "done",
            "testStrategy": "각 API 요청 스키마의 유효성 검증 테스트, 필수 필드 누락 시 에러 발생 확인",
            "parentId": "undefined",
            "updatedAt": "2026-01-14T12:38:10.124Z"
          },
          {
            "id": 3,
            "title": "API 응답 스키마 구현",
            "description": "API 응답에 필요한 스키마 정의 및 타입 추론 설정",
            "dependencies": [
              1
            ],
            "details": "각 API 엔드포인트의 응답 형식에 대한 스키마를 정의합니다. 성공 응답과 에러 응답에 대한 스키마를 분리하여 구현하고, 페이지네이션이나 필터링 결과 등 다양한 응답 형식을 고려하여 스키마를 설계합니다.",
            "status": "done",
            "testStrategy": "API 응답 스키마의 유효성 검증 테스트, 다양한 응답 패턴에 대한 타입 안전성 확인",
            "parentId": "undefined",
            "updatedAt": "2026-01-14T13:55:48.181Z"
          },
          {
            "id": 4,
            "title": "WebSocket 이벤트 스키마 구현",
            "description": "실시간 통신에 사용될 WebSocket 이벤트 스키마 정의",
            "dependencies": [
              1
            ],
            "details": "주문 상태 변경, 신규 주문 알림 등 WebSocket을 통해 전송될 이벤트 타입과 페이로드에 대한 스키마를 정의합니다. 이벤트 타입별로 필요한 데이터 구조를 설계하고, 클라이언트와 서버 간 일관된 타입 안전성을 보장합니다.",
            "status": "done",
            "testStrategy": "WebSocket 이벤트 스키마의 유효성 검증 테스트, 이벤트 타입별 페이로드 검증",
            "parentId": "undefined",
            "updatedAt": "2026-01-15T05:42:00.720Z"
          },
          {
            "id": 5,
            "title": "공통 유틸리티 타입 및 헬퍼 함수 구현",
            "description": "여러 스키마에서 공통으로 사용되는 유틸리티 타입과 헬퍼 함수 구현",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "페이지네이션, 정렬, 필터링 등 여러 API에서 공통으로 사용되는 유틸리티 타입과 헬퍼 함수를 구현합니다. 또한 타입 변환이나 검증에 필요한 유틸리티 함수도 함께 구현하여 코드 재사용성을 높입니다.",
            "status": "done",
            "testStrategy": "유틸리티 함수의 동작 검증 테스트, 다양한 입력에 대한 예상 출력 확인",
            "parentId": "undefined",
            "updatedAt": "2026-01-15T12:16:38.365Z"
          },
          {
            "id": 6,
            "title": "타입 확장 및 커스텀 타입 가드 구현",
            "description": "기본 스키마를 확장한 타입과 타입 안전성을 위한 커스텀 타입 가드 구현",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "기본 스키마를 확장하여 특정 상황에 필요한 추가 필드나 제약 조건을 가진 타입을 정의합니다. 또한 런타임에 타입 안전성을 보장하기 위한 커스텀 타입 가드 함수를 구현하여 타입 검증을 강화합니다.",
            "status": "done",
            "testStrategy": "확장된 타입의 유효성 검증 테스트, 타입 가드 함수의 정확성 검증",
            "parentId": "undefined",
            "updatedAt": "2026-01-15T12:22:44.209Z"
          },
          {
            "id": 7,
            "title": "스키마 문서화 및 예제 코드 작성",
            "description": "각 스키마의 사용법과 예제 코드를 문서화하여 개발자 경험 향상",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6
            ],
            "details": "각 스키마의 목적, 사용법, 제약 조건 등을 JSDoc 주석으로 문서화합니다. 또한 프론트엔드와 백엔드에서 스키마를 사용하는 예제 코드를 작성하여 개발자들이 쉽게 참조할 수 있도록 합니다.",
            "status": "done",
            "testStrategy": "문서화된 예제 코드의 실행 검증, JSDoc 주석의 완성도 확인",
            "parentId": "undefined",
            "updatedAt": "2026-01-15T12:27:19.655Z"
          },
          {
            "id": 8,
            "title": "스키마 통합 테스트 및 최적화",
            "description": "모든 스키마의 통합 테스트 및 성능 최적화",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6,
              7
            ],
            "details": "구현된 모든 스키마가 함께 작동할 때의 일관성과 타입 안전성을 검증하는 통합 테스트를 작성합니다. 또한 스키마 검증 성능을 최적화하고, 번들 크기를 줄이기 위한 최적화 작업을 수행합니다.",
            "status": "done",
            "testStrategy": "전체 스키마의 통합 테스트, 성능 벤치마크 테스트, 번들 크기 측정",
            "parentId": "undefined",
            "updatedAt": "2026-01-15T12:44:16.468Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "공유 타입을 기본 엔티티 스키마(Menu, Order), API 요청/응답 스키마, WebSocket 이벤트 스키마로 분리하여 각각의 검증 로직과 타입 추론을 독립적으로 구현할 수 있도록 세분화해주세요.",
        "updatedAt": "2026-01-15T12:44:16.468Z"
      },
      {
        "id": "4",
        "title": "Nest.js 백엔드 API 구현",
        "description": "메뉴 조회, 주문 생성, 주문 상태 관리를 위한 REST API 구현",
        "details": "1. Nest.js 프로젝트 초기화 및 Prisma 연동\n2. 메뉴 컨트롤러 구현:\n   - GET /api/menus (품절 메뉴 필터링)\n3. 주문 컨트롤러 구현:\n   - POST /api/orders (주문 생성, 스냅샷 저장)\n   - GET /api/orders?status=PENDING (주방용 주문 목록)\n   - PATCH /api/orders/:id/status (상태 변경)\n4. 주문 번호 자동 발급 로직 (일일 시퀀스)\n5. 단방향 상태 전환 검증 로직\n6. Zod 검증 파이프 적용\n7. 에러 핸들링 및 응답 포맷 통일\n8. CORS 설정",
        "testStrategy": "각 API 엔드포인트별 단위 테스트 작성, Postman으로 통합 테스트, 잘못된 요청에 대한 에러 응답 검증",
        "priority": "high",
        "dependencies": [
          "2",
          "3"
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Nest.js 프로젝트 초기화 및 Prisma 연동 설정",
            "description": "Nest.js 프로젝트를 생성하고 Prisma ORM을 연동하여 데이터베이스 접근 환경을 구축합니다.",
            "dependencies": [],
            "details": "1. Nest CLI를 사용하여 새 프로젝트 생성\n2. Prisma 패키지 설치 및 초기화\n3. Prisma 서비스 모듈 생성\n4. 데이터베이스 연결 설정 및 테스트\n5. 환경 변수 설정(.env 파일 구성)",
            "status": "done",
            "testStrategy": "데이터베이스 연결 테스트, Prisma 클라이언트 정상 작동 확인",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "메뉴 모듈 및 엔티티 구현",
            "description": "메뉴 관련 데이터 모델과 DTO를 정의하고 메뉴 모듈 구조를 설계합니다.",
            "dependencies": [
              1
            ],
            "details": "1. Menu 엔티티 정의\n2. 메뉴 관련 DTO 클래스 생성 (CreateMenuDto, UpdateMenuDto)\n3. 메뉴 모듈 생성 및 구조 설계\n4. Zod 스키마 정의 및 검증 로직 구현\n5. 메뉴 서비스 인터페이스 정의",
            "status": "done",
            "testStrategy": "엔티티와 DTO 클래스 유닛 테스트, Zod 스키마 검증 테스트",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "메뉴 서비스 및 리포지토리 구현",
            "description": "메뉴 데이터 접근 및 비즈니스 로직을 처리하는 서비스 계층을 구현합니다.",
            "dependencies": [
              2
            ],
            "details": "1. MenuRepository 클래스 구현\n2. MenuService 클래스 구현\n3. 메뉴 조회 로직 구현 (품절 메뉴 필터링 포함)\n4. 메뉴 CRUD 기능 구현\n5. 예외 처리 및 에러 핸들링 로직 추가",
            "status": "done",
            "testStrategy": "서비스 메소드 단위 테스트, 리포지토리 모킹을 통한 테스트",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "메뉴 컨트롤러 구현",
            "description": "메뉴 관련 REST API 엔드포인트를 제공하는 컨트롤러를 구현합니다.",
            "dependencies": [
              3
            ],
            "details": "1. MenuController 클래스 구현\n2. GET /api/menus 엔드포인트 구현 (품절 메뉴 필터링 옵션 포함)\n3. 쿼리 파라미터 처리 로직 구현\n4. 응답 포맷 표준화\n5. Swagger 문서화 추가",
            "status": "done",
            "testStrategy": "컨트롤러 엔드포인트 E2E 테스트, 응답 형식 및 상태 코드 검증",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "주문 모듈 및 엔티티 구현",
            "description": "주문 관련 데이터 모델과 DTO를 정의하고 주문 모듈 구조를 설계합니다.",
            "dependencies": [
              1
            ],
            "details": "1. Order 엔티티 정의 (상태 열거형 포함)\n2. 주문 관련 DTO 클래스 생성 (CreateOrderDto, UpdateOrderStatusDto)\n3. 주문 모듈 생성 및 구조 설계\n4. Zod 스키마 정의 및 검증 로직 구현\n5. 주문 서비스 인터페이스 정의",
            "status": "done",
            "testStrategy": "엔티티와 DTO 클래스 유닛 테스트, 상태 전환 로직 검증",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "주문 번호 자동 발급 서비스 구현",
            "description": "일일 시퀀스 기반의 주문 번호를 자동으로 발급하는 서비스를 구현합니다.",
            "dependencies": [
              5
            ],
            "details": "1. OrderNumberService 클래스 구현\n2. 일일 시퀀스 생성 및 관리 로직 구현\n3. 날짜 변경 시 시퀀스 리셋 로직 구현\n4. 동시성 이슈 처리 로직 구현\n5. 주문 번호 포맷팅 기능 구현",
            "status": "done",
            "testStrategy": "다양한 시나리오에서의 주문 번호 생성 테스트, 날짜 변경 시 동작 검증",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "주문 상태 관리 서비스 구현",
            "description": "주문 상태 전환 및 검증 로직을 처리하는 서비스를 구현합니다.",
            "dependencies": [
              5
            ],
            "details": "1. OrderStatusService 클래스 구현\n2. 상태 전환 규칙 정의 (상태 머신 구현)\n3. 단방향 상태 전환 검증 로직 구현\n4. 잘못된 상태 전환 시 예외 처리\n5. 상태 변경 이력 기록 기능 구현",
            "status": "done",
            "testStrategy": "상태 전환 규칙 준수 여부 테스트, 잘못된 상태 전환 시 예외 발생 검증",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "주문 서비스 및 리포지토리 구현",
            "description": "주문 데이터 접근 및 비즈니스 로직을 처리하는 서비스 계층을 구현합니다.",
            "dependencies": [
              6,
              7
            ],
            "details": "1. OrderRepository 클래스 구현\n2. OrderService 클래스 구현\n3. 주문 생성 로직 구현 (메뉴 스냅샷 저장 포함)\n4. 주문 상태별 조회 로직 구현\n5. 주문 상태 변경 로직 구현",
            "status": "done",
            "testStrategy": "서비스 메소드 단위 테스트, 주문 생성 및 상태 변경 시나리오 테스트",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "주문 컨트롤러 구현",
            "description": "주문 관련 REST API 엔드포인트를 제공하는 컨트롤러를 구현합니다.",
            "dependencies": [
              8
            ],
            "details": "1. OrderController 클래스 구현\n2. POST /api/orders 엔드포인트 구현 (주문 생성)\n3. GET /api/orders 엔드포인트 구현 (상태별 필터링)\n4. PATCH /api/orders/:id/status 엔드포인트 구현 (상태 변경)\n5. Swagger 문서화 추가",
            "status": "done",
            "testStrategy": "컨트롤러 엔드포인트 E2E 테스트, 주문 생성 및 상태 변경 시나리오 테스트",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Zod 검증 파이프 구현",
            "description": "Zod 스키마를 사용하여 요청 데이터를 검증하는 커스텀 파이프를 구현합니다.",
            "dependencies": [
              2,
              5
            ],
            "details": "1. ZodValidationPipe 클래스 구현\n2. Nest.js 파이프 인터페이스 구현\n3. Zod 스키마 기반 검증 로직 구현\n4. 검증 실패 시 예외 처리 로직 구현\n5. 글로벌 또는 컨트롤러별 파이프 적용 설정",
            "status": "done",
            "testStrategy": "다양한 입력 데이터에 대한 검증 테스트, 잘못된 입력 시 적절한 에러 응답 검증",
            "parentId": "undefined"
          },
          {
            "id": 11,
            "title": "글로벌 예외 필터 및 응답 포맷 구현",
            "description": "애플리케이션 전반의 예외를 처리하고 일관된 응답 형식을 제공하는 필터를 구현합니다.",
            "dependencies": [
              1
            ],
            "details": "1. GlobalExceptionFilter 클래스 구현\n2. 표준 응답 포맷 정의 (성공/실패 응답 구조)\n3. 다양한 예외 유형별 처리 로직 구현\n4. HTTP 상태 코드 매핑 로직 구현\n5. 로깅 및 에러 추적 기능 추가",
            "status": "done",
            "testStrategy": "다양한 예외 상황에서의 응답 형식 검증, 로깅 기능 테스트",
            "parentId": "undefined"
          },
          {
            "id": 12,
            "title": "CORS 및 보안 설정 구현",
            "description": "API의 보안을 강화하고 클라이언트 접근을 제어하는 CORS 및 보안 설정을 구현합니다.",
            "dependencies": [
              1
            ],
            "details": "1. CORS 미들웨어 설정\n2. 허용된 오리진 및 메소드 설정\n3. Helmet 보안 헤더 설정\n4. Rate Limiting 구현\n5. API 키 또는 기본 인증 구현 (필요 시)",
            "status": "done",
            "testStrategy": "다양한 오리진에서의 API 접근 테스트, 보안 헤더 검증, 요청 제한 테스트",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "백엔드 API를 Nest.js 프로젝트 초기화, 메뉴 관리 API, 주문 생성 API, 주문 상태 관리 API, 에러 핸들링 및 검증 파이프로 분리하여 각 API 엔드포인트를 독립적으로 개발하고 테스트할 수 있도록 세분화해주세요."
      },
      {
        "id": "5",
        "title": "WebSocket 실시간 통신 구현",
        "description": "Socket.io를 사용한 실시간 주문 알림 시스템 구현",
        "details": "1. Socket.io 설치 및 Nest.js Gateway 설정\n2. 룸 관리 로직:\n   - kitchen: 전체 주방용\n   - order_${orderId}: 개별 고객용\n3. 이벤트 정의:\n   - new_order: 신규 주문 시 주방에 알림\n   - order_ready: 조리 완료 시 고객에게 알림\n4. 연결 관리:\n   - 클라이언트 연결/해제 처리\n   - 룸 조인/리브 로직\n5. 하트비트 구현 (30초 간격)\n6. 에러 핸들링 및 재연결 로직\n7. CORS 설정",
        "testStrategy": "Socket.io 클라이언트로 연결 테스트, 이벤트 송수신 검증, 룸 격리 테스트, 연결 끊김 시나리오 테스트",
        "priority": "medium",
        "dependencies": [
          "4"
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Socket.io 설치 및 Nest.js Gateway 기본 설정",
            "description": "Socket.io 라이브러리를 설치하고 Nest.js에서 WebSocket Gateway 기본 구조 설정하기",
            "dependencies": [],
            "details": "Socket.io 패키지 설치 (@nestjs/websockets, @nestjs/platform-socket.io), Gateway 클래스 생성 및 기본 데코레이터 설정, 모듈에 Gateway 등록, CORS 설정 구성, 기본 연결 이벤트 핸들러 구현",
            "status": "done",
            "testStrategy": "Gateway가 정상적으로 초기화되는지 확인, 기본 연결 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-18T05:53:18.558Z"
          },
          {
            "id": 2,
            "title": "주방용 룸(kitchen) 관리 로직 구현",
            "description": "주방 직원들이 접속할 수 있는 'kitchen' 룸 관리 로직 구현",
            "dependencies": [
              1
            ],
            "details": "주방 직원 인증 로직 구현, kitchen 룸 생성 및 관리, 주방 직원 연결/해제 시 kitchen 룸 조인/리브 처리, 주방 직원 목록 관리 및 상태 추적, 주방 룸 전용 이벤트 핸들러 구현",
            "status": "done",
            "testStrategy": "주방 룸 연결/해제 테스트, 여러 주방 클라이언트 동시 접속 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-18T06:57:58.453Z"
          },
          {
            "id": 3,
            "title": "고객용 주문별 룸(order_${orderId}) 관리 로직 구현",
            "description": "각 고객이 자신의 주문 상태를 실시간으로 받을 수 있는 주문별 룸 관리 로직 구현",
            "dependencies": [
              1
            ],
            "details": "주문 ID 기반 동적 룸 생성 로직(order_${orderId}), 고객 인증 및 본인 주문 룸만 접근 가능하도록 제한, 주문 상태 변경 시 해당 룸에만 이벤트 발송, 주문 완료 후 룸 정리 로직, 고객별 연결 상태 관리",
            "status": "done",
            "testStrategy": "주문별 룸 격리 테스트, 다른 주문 룸으로 이벤트가 전달되지 않는지 확인",
            "parentId": "undefined",
            "updatedAt": "2026-01-18T11:12:21.465Z"
          },
          {
            "id": 4,
            "title": "new_order 이벤트 구현",
            "description": "신규 주문 발생 시 주방에 알림을 보내는 new_order 이벤트 구현",
            "dependencies": [
              2
            ],
            "details": "주문 생성 API와 연동하여 new_order 이벤트 발생 로직 구현, 주문 데이터 포맷팅 및 kitchen 룸으로 이벤트 전송, 주문 접수 확인 응답 처리, 이벤트 페이로드 타입 정의, 주문 메타데이터 포함(시간, 메뉴 등)",
            "status": "done",
            "testStrategy": "주문 생성 시 주방에 실시간 알림이 전달되는지 테스트, 페이로드 데이터 정확성 검증",
            "parentId": "undefined",
            "updatedAt": "2026-01-18T11:55:43.811Z"
          },
          {
            "id": 5,
            "title": "order_ready 이벤트 구현",
            "description": "주문 준비 완료 시 고객에게 알림을 보내는 order_ready 이벤트 구현",
            "dependencies": [
              3
            ],
            "details": "주문 상태 변경 API와 연동하여 order_ready 이벤트 발생 로직 구현, 주문 상태가 'READY'로 변경될 때 해당 주문 룸으로 이벤트 전송, 고객 확인 응답 처리, 이벤트 페이로드 타입 정의, 픽업 위치 등 추가 정보 포함",
            "status": "done",
            "testStrategy": "주문 상태 변경 시 해당 고객에게만 알림이 전달되는지 테스트, 다른 고객에게는 전달되지 않는지 확인",
            "parentId": "undefined",
            "updatedAt": "2026-01-18T12:03:26.872Z"
          },
          {
            "id": 6,
            "title": "클라이언트 연결/해제 처리 로직 구현",
            "description": "클라이언트 연결 및 해제 시 필요한 처리 로직 구현",
            "dependencies": [
              1
            ],
            "details": "handleConnection, handleDisconnect 메서드 구현, 연결 시 사용자 타입(주방/고객) 식별 및 적절한 룸 할당, 연결 메타데이터 저장 및 관리, 해제 시 메모리 정리 및 상태 업데이트, 연결 통계 수집 및 모니터링 로직",
            "status": "done",
            "testStrategy": "클라이언트 연결/해제 시 적절한 이벤트가 발생하는지 테스트, 메모리 누수 확인",
            "parentId": "undefined",
            "updatedAt": "2026-01-18T12:09:01.545Z"
          },
          {
            "id": 7,
            "title": "하트비트 메커니즘 구현",
            "description": "30초 간격으로 연결 상태를 확인하는 하트비트 메커니즘 구현",
            "dependencies": [
              6
            ],
            "details": "30초 간격 하트비트 이벤트 설정, 클라이언트 응답 타임아웃 처리, 무응답 클라이언트 정리 로직, 재연결 시도 횟수 제한 설정, 하트비트 응답 통계 수집, 비정상 종료된 연결 감지 및 정리",
            "status": "done",
            "testStrategy": "하트비트 주기 정확성 테스트, 무응답 클라이언트 처리 테스트, 네트워크 지연 시뮬레이션",
            "parentId": "undefined",
            "updatedAt": "2026-01-18T12:44:07.983Z"
          },
          {
            "id": 8,
            "title": "에러 핸들링 및 예외 처리 구현",
            "description": "WebSocket 통신 중 발생할 수 있는 다양한 에러 상황에 대한 처리 로직 구현",
            "dependencies": [
              1,
              6
            ],
            "details": "연결 오류, 메시지 전송 실패, 인증 오류 등 예외 상황 처리, 에러 로깅 및 모니터링 설정, 클라이언트에게 적절한 에러 메시지 전달, 치명적 오류 발생 시 복구 전략, 에러 타입별 대응 로직 구현",
            "status": "in-progress",
            "testStrategy": "다양한 에러 상황 시뮬레이션 및 처리 검증, 에러 메시지 포맷 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-18T12:46:11.647Z"
          },
          {
            "id": 9,
            "title": "재연결 로직 구현",
            "description": "네트워크 불안정 등으로 연결이 끊긴 경우 재연결을 처리하는 로직 구현",
            "dependencies": [
              6,
              7,
              8
            ],
            "details": "지수 백오프 알고리즘을 사용한 재연결 시도 로직, 재연결 시 이전 상태 복구 메커니즘, 최대 재시도 횟수 설정, 재연결 실패 시 최종 처리 로직, 일시적 연결 끊김과 영구적 연결 끊김 구분, 재연결 시 인증 토큰 갱신",
            "status": "pending",
            "testStrategy": "네트워크 끊김 시뮬레이션 후 재연결 테스트, 재연결 시 상태 유지 확인",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "WebSocket 통합 테스트 및 최적화",
            "description": "구현된 WebSocket 기능들의 통합 테스트 및 성능 최적화",
            "dependencies": [
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9
            ],
            "details": "전체 WebSocket 기능 통합 테스트 시나리오 작성 및 실행, 부하 테스트를 통한 성능 병목 식별, 메모리 사용량 최적화, 이벤트 처리 지연 시간 측정 및 개선, 동시 접속자 처리 능력 테스트, 로깅 및 모니터링 설정 최적화, 문서화",
            "status": "pending",
            "testStrategy": "엔드투엔드 테스트 시나리오 실행, 부하 테스트(100명 이상 동시 접속), 장시간 실행 안정성 테스트",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 4,
        "expansionPrompt": "WebSocket 구현을 Socket.io Gateway 설정, 룸 관리 및 이벤트 정의, 연결 관리 및 하트비트, 에러 핸들링 및 재연결 로직으로 분리하여 실시간 통신의 각 측면을 독립적으로 구현하고 테스트할 수 있도록 세분화해주세요.",
        "updatedAt": "2026-01-18T12:46:11.647Z"
      },
      {
        "id": "6",
        "title": "고객용 주문 화면 구현",
        "description": "QR 스캔 후 메뉴 선택 및 주문 완료까지의 고객 화면 구현",
        "details": "1. Next.js 14 App Router 설정\n2. shadcn/ui 및 Tailwind CSS 설정\n3. /order 페이지 구현:\n   - QR 파라미터 파싱 (?storeId=1&tableId=5)\n   - 메뉴 리스트 UI (Card 컴포넌트)\n   - 수량 조절 버튼 (+/- 44x44px 이상)\n   - 장바구니 Drawer (하단 고정)\n4. Zustand 상태 관리:\n   ```typescript\n   interface CartStore {\n     items: CartItem[];\n     addItem: (menu: Menu, count: number) => void;\n     removeItem: (menuId: string) => void;\n     updateCount: (menuId: string, count: number) => void;\n     getTotalPrice: () => number;\n     clear: () => void;\n   }\n   ```\n5. LocalStorage 동기화\n6. 주문 완료 화면 (주문번호 표시)\n7. 모바일 최적화 (반응형 디자인)\n8. 로딩 상태 및 에러 처리",
        "testStrategy": "모바일 브라우저에서 QR 스캔부터 주문 완료까지 E2E 테스트, 장바구니 상태 관리 테스트, LocalStorage 동기화 검증",
        "priority": "high",
        "dependencies": [
          "4"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Next.js 14 프로젝트 설정 및 기본 구조 구성",
            "description": "Next.js 14 App Router를 사용한 프로젝트 초기 설정 및 기본 디렉토리 구조 구성",
            "dependencies": [],
            "details": "1. Next.js 14 설치 및 App Router 설정\n2. TypeScript 설정\n3. 기본 디렉토리 구조 생성 (app, components, lib, hooks 등)\n4. 환경 변수 설정 (.env.local)\n5. 기본 레이아웃 컴포넌트 생성",
            "status": "pending",
            "testStrategy": "Next.js 개발 서버 정상 실행 확인 및 기본 페이지 렌더링 테스트",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "UI 라이브러리 및 스타일링 설정",
            "description": "shadcn/ui 및 Tailwind CSS 설정과 기본 테마 구성",
            "dependencies": [
              1
            ],
            "details": "1. Tailwind CSS 설치 및 설정\n2. shadcn/ui 설치 및 컴포넌트 초기화\n3. 테마 설정 (다크모드/라이트모드)\n4. 글로벌 스타일 설정\n5. 공통 UI 컴포넌트 구성 (버튼, 카드, 입력 필드 등)",
            "status": "pending",
            "testStrategy": "컴포넌트 스토리북 또는 테스트 페이지에서 UI 컴포넌트 렌더링 확인",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "QR 코드 파라미터 파싱 및 초기 데이터 로딩 구현",
            "description": "URL에서 storeId와 tableId 파라미터를 파싱하고 초기 데이터를 로딩하는 기능 구현",
            "dependencies": [
              1,
              2
            ],
            "details": "1. /order 페이지 생성\n2. URL 쿼리 파라미터 파싱 로직 구현 (storeId, tableId)\n3. 파라미터 유효성 검증\n4. 매장 정보 및 테이블 정보 API 연동\n5. 로딩 상태 UI 구현\n6. 에러 처리 및 에러 페이지 구현",
            "status": "pending",
            "testStrategy": "다양한 QR 파라미터 조합으로 파싱 정확성 테스트 및 에러 케이스 처리 검증",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "메뉴 리스트 UI 구현",
            "description": "매장의 메뉴 목록을 표시하는 UI 컴포넌트 구현",
            "dependencies": [
              2,
              3
            ],
            "details": "1. 메뉴 카테고리 탭 UI 구현\n2. 메뉴 카드 컴포넌트 구현 (이미지, 이름, 가격, 품절 표시)\n3. 메뉴 리스트 그리드 레이아웃 구현\n4. 메뉴 검색 기능 구현\n5. 메뉴 필터링 기능 구현 (카테고리별, 가격별)\n6. 무한 스크롤 또는 페이지네이션 구현",
            "status": "pending",
            "testStrategy": "다양한 화면 크기에서 메뉴 리스트 UI 렌더링 테스트 및 필터링/검색 기능 검증",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "메뉴 상세 정보 모달 구현",
            "description": "메뉴 카드 클릭 시 상세 정보를 보여주는 모달 구현",
            "dependencies": [
              4
            ],
            "details": "1. 메뉴 상세 정보 모달 컴포넌트 구현\n2. 메뉴 이미지 갤러리 구현\n3. 메뉴 설명 및 영양 정보 표시\n4. 옵션 선택 UI 구현 (있는 경우)\n5. 수량 조절 UI 구현 (+/- 버튼, 44x44px 이상)\n6. 장바구니 담기 버튼 구현",
            "status": "pending",
            "testStrategy": "모달 열기/닫기 동작 테스트, 옵션 선택 및 수량 조절 기능 검증",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Zustand 장바구니 상태 관리 구현",
            "description": "Zustand를 사용한 장바구니 상태 관리 스토어 구현",
            "dependencies": [
              1
            ],
            "details": "1. CartStore 인터페이스 구현\n2. Zustand 스토어 생성\n3. 장바구니 아이템 추가/제거/수정 함수 구현\n4. 총 가격 계산 함수 구현\n5. 장바구니 초기화 함수 구현\n6. 타입 안전성 보장 (TypeScript)",
            "status": "pending",
            "testStrategy": "장바구니 상태 변경 함수들의 단위 테스트 및 상태 업데이트 검증",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "LocalStorage 동기화 구현",
            "description": "장바구니 상태를 LocalStorage와 동기화하는 기능 구현",
            "dependencies": [
              6
            ],
            "details": "1. LocalStorage 저장/불러오기 유틸리티 함수 구현\n2. Zustand 상태 변경 시 LocalStorage 자동 업데이트\n3. 페이지 로드 시 LocalStorage에서 장바구니 상태 복원\n4. 브라우저 탭 간 동기화 구현 (StorageEvent 활용)\n5. 에러 처리 및 폴백 메커니즘 구현",
            "status": "pending",
            "testStrategy": "브라우저 새로고침 후 장바구니 상태 유지 테스트 및 다중 탭 동기화 검증",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "장바구니 Drawer UI 구현",
            "description": "화면 하단에 고정된 장바구니 Drawer UI 구현",
            "dependencies": [
              2,
              6,
              7
            ],
            "details": "1. 하단 고정 장바구니 요약 바 구현 (금액, 아이템 수)\n2. Drawer 컴포넌트 구현 (위로 스와이프 동작)\n3. 장바구니 아이템 리스트 UI 구현\n4. 아이템별 수량 조절 UI 구현 (+/- 버튼)\n5. 아이템 삭제 기능 구현\n6. 주문하기 버튼 구현",
            "status": "pending",
            "testStrategy": "Drawer 열기/닫기 동작 테스트, 장바구니 아이템 조작 기능 검증, 모바일 터치 제스처 테스트",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "주문 프로세스 구현",
            "description": "장바구니에서 주문하기 버튼 클릭 후 주문 처리 프로세스 구현",
            "dependencies": [
              6,
              8
            ],
            "details": "1. 주문 확인 모달 구현\n2. 주문 API 연동 (POST /api/orders)\n3. 주문 상태 관리 (로딩, 성공, 실패)\n4. 주문 완료 후 장바구니 초기화\n5. 주문 완료 페이지로 리다이렉트\n6. 에러 처리 및 재시도 메커니즘 구현",
            "status": "pending",
            "testStrategy": "주문 API 연동 테스트, 다양한 주문 시나리오 및 에러 케이스 테스트",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "주문 완료 화면 구현",
            "description": "주문 완료 후 주문 번호와 안내 메시지를 표시하는 화면 구현",
            "dependencies": [
              9
            ],
            "details": "1. 주문 완료 페이지 (/order/complete) 구현\n2. 주문 번호 표시 UI 구현\n3. 주문 상세 정보 표시\n4. 예상 준비 시간 표시\n5. 주문 상태 실시간 업데이트 (WebSocket 또는 폴링)\n6. 새 주문하기 버튼 구현",
            "status": "pending",
            "testStrategy": "주문 완료 화면 렌더링 테스트, 주문 상태 업데이트 기능 검증",
            "parentId": "undefined"
          },
          {
            "id": 11,
            "title": "모바일 최적화 및 반응형 디자인 구현",
            "description": "다양한 모바일 기기에서 최적의 사용자 경험을 제공하기 위한 반응형 디자인 구현",
            "dependencies": [
              4,
              5,
              8,
              10
            ],
            "details": "1. 모바일 뷰포트 설정\n2. 반응형 그리드 레이아웃 구현\n3. 터치 친화적 UI 요소 크기 조정 (최소 44x44px)\n4. 모바일 제스처 지원 (스와이프, 핀치 줌 등)\n5. 모바일 키보드 대응\n6. 다양한 화면 크기 테스트 및 최적화",
            "status": "pending",
            "testStrategy": "다양한 모바일 기기 및 화면 크기에서 UI 테스트, 터치 제스처 동작 검증",
            "parentId": "undefined"
          },
          {
            "id": 12,
            "title": "로딩 상태 및 에러 처리 구현",
            "description": "전체 애플리케이션에서 일관된 로딩 상태 표시 및 에러 처리 구현",
            "dependencies": [
              3,
              4,
              9
            ],
            "details": "1. 글로벌 로딩 인디케이터 컴포넌트 구현\n2. 스켈레톤 로딩 UI 구현 (메뉴 리스트, 장바구니 등)\n3. API 에러 처리 유틸리티 함수 구현\n4. 에러 경계 (Error Boundary) 컴포넌트 구현\n5. 사용자 친화적 에러 메시지 표시\n6. 오프라인 상태 처리 및 알림",
            "status": "pending",
            "testStrategy": "다양한 네트워크 상태에서 로딩/에러 UI 테스트, 에러 복구 메커니즘 검증",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "고객 화면을 Next.js 프로젝트 설정 및 UI 라이브러리 구성, 메뉴 리스트 및 상품 카드 UI, 장바구니 상태 관리 및 Zustand 스토어, 주문 프로세스 및 완료 화면, 모바일 최적화 및 반응형 디자인으로 분리하여 각 화면과 기능을 독립적으로 개발할 수 있도록 세분화해주세요."
      },
      {
        "id": "7",
        "title": "주방용 주문 관리 화면 구현",
        "description": "태블릿에서 사용할 주문 현황판 및 상태 관리 화면 구현",
        "details": "1. /kitchen 페이지 구현 (가로 모드 최적화)\n2. 주문 카드 그리드 레이아웃 (3-4열)\n3. 주문 카드 컴포넌트:\n   - 주문번호, 메뉴 리스트, 수량, 경과시간\n   - '호출' 버튼 (60x60px 이상)\n   - '수령 확인' 버튼\n4. 실시간 주문 목록 조회 및 정렬:\n   - createdAt 기준 오름차순 (오래된 주문 우선)\n   - 색상 코딩 (오래된 주문: 빨강, 최근 주문: 초록)\n5. 상태 변경 API 호출:\n   - PENDING → READY\n   - READY → COMPLETED\n6. 에러 처리 및 롤백 로직\n7. 태블릿 터치 최적화",
        "testStrategy": "태블릿 환경에서 터치 조작 테스트, 주문 카드 표시 및 상태 변경 검증, 정렬 로직 테스트",
        "priority": "high",
        "dependencies": [
          "4"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "태블릿 최적화 레이아웃 기본 구조 구현",
            "description": "주방용 태블릿 화면의 기본 레이아웃 구조를 구현하고 가로 모드에 최적화",
            "dependencies": [],
            "details": "/kitchen 페이지 생성 및 가로 모드 최적화 레이아웃 설정. 반응형 그리드 시스템 구현 및 태블릿 화면 크기에 맞는 기본 UI 컴포넌트 배치. 화면 회전 시 레이아웃 안정성 보장.",
            "status": "pending",
            "testStrategy": "다양한 태블릿 크기와 해상도에서 레이아웃 테스트, 가로/세로 모드 전환 시 안정성 검증",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "주문 카드 그리드 레이아웃 구현",
            "description": "주문 카드를 표시할 3-4열 그리드 레이아웃 시스템 구현",
            "dependencies": [
              1
            ],
            "details": "CSS Grid 또는 Flexbox를 활용하여 3-4열 그리드 레이아웃 구현. 태블릿 화면 크기에 따라 동적으로 열 수 조정. 카드 간 간격 및 정렬 최적화. 스크롤 시 성능 최적화.",
            "status": "pending",
            "testStrategy": "다양한 주문 수량에서 그리드 레이아웃 테스트, 스크롤 성능 측정",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "주문 카드 컴포넌트 개발",
            "description": "주문 정보를 표시하는 카드 컴포넌트 구현 (주문번호, 메뉴, 수량, 경과시간 등)",
            "dependencies": [
              2
            ],
            "details": "주문 카드 컴포넌트 개발: 주문번호, 메뉴 리스트, 수량, 주문 경과시간 표시. 호출 버튼(60x60px 이상) 및 수령 확인 버튼 구현. 터치 영역 최적화 및 시각적 피드백 추가.",
            "status": "pending",
            "testStrategy": "다양한 주문 데이터로 카드 렌더링 테스트, 버튼 터치 영역 및 반응성 검증",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "실시간 주문 목록 조회 API 연동",
            "description": "백엔드 API와 연동하여 실시간 주문 목록을 조회하는 기능 구현",
            "dependencies": [
              1
            ],
            "details": "주문 API 엔드포인트 연결 및 데이터 페칭 로직 구현. React Query 또는 SWR을 사용한 데이터 캐싱 및 자동 갱신 설정. 폴링 또는 웹소켓을 통한 실시간 데이터 업데이트 구현. 로딩 및 에러 상태 처리.",
            "status": "pending",
            "testStrategy": "API 응답 시나리오별 테스트, 네트워크 지연 및 오류 상황 대응 검증",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "주문 정렬 및 색상 코딩 로직 구현",
            "description": "주문을 생성 시간 기준으로 정렬하고 경과 시간에 따른 색상 코딩 적용",
            "dependencies": [
              3,
              4
            ],
            "details": "createdAt 기준 오름차순 정렬 로직 구현(오래된 주문 우선). 주문 경과 시간에 따른 색상 코딩 시스템 개발(오래된 주문: 빨강, 최근 주문: 초록). 시간 경과에 따른 동적 색상 변경 로직 구현. 정렬 및 필터링 옵션 추가.",
            "status": "pending",
            "testStrategy": "다양한 시간대 주문 데이터로 정렬 및 색상 코딩 정확성 검증",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "주문 상태 변경 기능 구현",
            "description": "주문 상태를 변경하는 버튼 및 API 연동 구현 (PENDING → READY → COMPLETED)",
            "dependencies": [
              3,
              4
            ],
            "details": "상태 변경 API 엔드포인트 연결. PENDING → READY, READY → COMPLETED 상태 전환 로직 구현. 상태 변경 버튼 UI 및 이벤트 핸들러 개발. 상태 변경 시 시각적 피드백 및 애니메이션 추가.",
            "status": "pending",
            "testStrategy": "상태 변경 API 호출 테스트, 상태 전환 시 UI 업데이트 검증",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "에러 처리 및 롤백 로직 구현",
            "description": "API 호출 실패 시 에러 처리 및 상태 롤백 로직 구현",
            "dependencies": [
              6
            ],
            "details": "API 호출 실패 시 에러 처리 로직 구현. 상태 변경 실패 시 롤백 메커니즘 개발. 사용자에게 에러 알림 UI 구현(토스트 또는 모달). 네트워크 재연결 시 자동 재시도 로직 추가. 오프라인 상태 감지 및 대응.",
            "status": "pending",
            "testStrategy": "네트워크 오류 시나리오 테스트, 롤백 로직 정확성 검증, 오프라인 모드 테스트",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "태블릿 터치 최적화 및 제스처 구현",
            "description": "태블릿 환경에 최적화된 터치 인터랙션 및 제스처 기능 구현",
            "dependencies": [
              3,
              6
            ],
            "details": "터치 이벤트 최적화 및 반응성 향상. 스와이프 제스처를 통한 주문 상태 변경 기능 구현. 핀치 줌 및 드래그 기능 추가. 터치 피드백 애니메이션 구현. 터치 타겟 크기 최적화(최소 44x44px).",
            "status": "pending",
            "testStrategy": "실제 태블릿 기기에서 터치 반응성 테스트, 다양한 제스처 동작 검증",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "주문 알림 및 소리 기능 구현",
            "description": "새 주문 발생 시 시각적/청각적 알림 기능 구현",
            "dependencies": [
              4
            ],
            "details": "새 주문 발생 시 시각적 알림 효과 구현. 알림음 재생 기능 개발(볼륨 조절 가능). 브라우저 알림 API 활용. 알림 설정 토글 UI 구현. 장시간 미처리 주문에 대한 반복 알림 로직 추가.",
            "status": "pending",
            "testStrategy": "다양한 알림 시나리오 테스트, 소리 재생 기능 검증, 브라우저 알림 권한 처리 테스트",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "성능 최적화 및 최종 테스트",
            "description": "태블릿 환경에서의 성능 최적화 및 전체 기능 테스트",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9
            ],
            "details": "컴포넌트 렌더링 성능 최적화(메모이제이션, 가상화). 이미지 및 애셋 최적화. 배터리 사용량 최적화. 장시간 사용 시 메모리 누수 방지. 다양한 태블릿 기기 및 브라우저에서 종합 테스트 진행. 사용자 피드백 수집 및 UI/UX 개선.",
            "status": "pending",
            "testStrategy": "성능 메트릭 측정(FPS, 메모리 사용량), 장시간 사용 테스트, 다양한 태블릿 기기 호환성 검증",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "주방 화면을 태블릿 최적화 레이아웃 구성, 주문 카드 컴포넌트 및 그리드 시스템, 실시간 주문 목록 조회 및 정렬 로직, 주문 상태 변경 및 에러 처리로 분리하여 태블릿 환경에 특화된 각 기능을 독립적으로 구현할 수 있도록 세분화해주세요."
      },
      {
        "id": "8",
        "title": "실시간 알림 시스템 통합",
        "description": "WebSocket을 통한 양방향 실시간 알림 기능 구현",
        "details": "1. Socket.io 클라이언트 설정 및 Zustand 스토어:\n   ```typescript\n   interface SocketStore {\n     socket: Socket | null;\n     isConnected: boolean;\n     connect: (roomId: string) => void;\n     disconnect: () => void;\n     joinRoom: (roomId: string) => void;\n   }\n   ```\n2. 고객 화면 알림:\n   - order_ready 이벤트 수신\n   - Toast 알림 표시\n   - 진동 API 호출 (navigator.vibrate)\n   - 화면 자동 갱신\n3. 주방 화면 알림:\n   - new_order 이벤트 수신\n   - 알림음 재생 (Audio API)\n   - 신규 주문 카드 자동 추가\n   - 리스트 자동 갱신\n4. 재연결 로직:\n   - 연결 끊김 감지\n   - 지수 백오프 재연결 (3초, 6초, 12초...)\n   - 최대 5회 시도\n5. 폴링 폴백 (WebSocket 실패 시)",
        "testStrategy": "주방에서 호출 버튼 클릭 시 고객에게 3초 내 알림 전달 검증, 네트워크 끊김 시나리오 테스트, 재연결 로직 검증",
        "priority": "high",
        "dependencies": [
          "5",
          "6",
          "7"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Socket.io 클라이언트 설정 및 Zustand 스토어 구현",
            "description": "Socket.io 클라이언트를 설정하고 Zustand 상태 관리 스토어와 통합하는 기능 구현",
            "dependencies": [],
            "details": "Socket.io 클라이언트 라이브러리 설치 및 초기화, Zustand 스토어 생성, 소켓 연결/해제 메서드 구현, 룸 참여 기능 구현, 연결 상태 관리 로직 개발, 타입스크립트 인터페이스 정의 및 적용",
            "status": "pending",
            "testStrategy": "소켓 연결/해제 기능 테스트, 룸 참여 기능 테스트, 연결 상태 변화 감지 테스트",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "고객 화면 알림 시스템 구현",
            "description": "고객 화면에서 주문 준비 완료 알림을 수신하고 표시하는 기능 구현",
            "dependencies": [
              1
            ],
            "details": "order_ready 이벤트 리스너 등록, Toast 알림 컴포넌트 개발, 진동 API(navigator.vibrate) 연동, 화면 자동 갱신 로직 구현, 알림 수신 시 상태 업데이트 처리, 모바일 환경 최적화",
            "status": "pending",
            "testStrategy": "order_ready 이벤트 수신 테스트, Toast 알림 표시 검증, 진동 API 호출 확인, 화면 갱신 동작 확인",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "주방 화면 알림 시스템 구현",
            "description": "주방 화면에서 신규 주문 알림을 수신하고 표시하는 기능 구현",
            "dependencies": [
              1
            ],
            "details": "new_order 이벤트 리스너 등록, 알림음 재생 기능 구현(Audio API), 신규 주문 카드 자동 추가 로직 개발, 주문 리스트 자동 갱신 기능 구현, 알림 수신 시 상태 업데이트 처리, 주방 화면 UI 최적화",
            "status": "pending",
            "testStrategy": "new_order 이벤트 수신 테스트, 알림음 재생 확인, 주문 카드 자동 추가 검증, 리스트 갱신 동작 확인",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "소켓 재연결 로직 구현",
            "description": "네트워크 연결 끊김 감지 및 자동 재연결 로직 개발",
            "dependencies": [
              1
            ],
            "details": "연결 끊김 이벤트 감지 구현, 지수 백오프 알고리즘 적용(3초, 6초, 12초...), 최대 재시도 횟수 제한(5회), 재연결 시도 중 상태 표시, 재연결 성공/실패 처리 로직 구현, 사용자 피드백 UI 개발",
            "status": "pending",
            "testStrategy": "네트워크 끊김 시나리오 테스트, 재연결 시도 간격 검증, 최대 재시도 횟수 제한 확인, 재연결 성공/실패 처리 검증",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "폴링 폴백 메커니즘 구현",
            "description": "WebSocket 연결 실패 시 HTTP 폴링으로 대체하는 폴백 메커니즘 개발",
            "dependencies": [
              4
            ],
            "details": "WebSocket 연결 실패 감지 로직, HTTP 폴링 구현(주기적 API 호출), 폴링 간격 설정(5초), 폴링 데이터와 소켓 데이터 통합 로직, 네트워크 상태 복구 시 WebSocket 재연결 처리, 폴링/소켓 모드 전환 UI 표시",
            "status": "pending",
            "testStrategy": "WebSocket 실패 시 폴링 전환 테스트, 폴링 간격 검증, 네트워크 복구 시 WebSocket 재연결 확인, 데이터 일관성 테스트",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "이벤트 핸들러 및 미들웨어 구현",
            "description": "소켓 이벤트 처리를 위한 핸들러 및 미들웨어 개발",
            "dependencies": [
              1
            ],
            "details": "이벤트 타입 정의 및 타입 안전성 확보, 이벤트 핸들러 구조 설계, 미들웨어 체인 구현(로깅, 에러 처리), 이벤트 전파 메커니즘 개발, 디바운싱/쓰로틀링 적용, 이벤트 버스 패턴 구현, 이벤트 히스토리 관리",
            "status": "pending",
            "testStrategy": "이벤트 핸들러 동작 테스트, 미들웨어 체인 검증, 에러 처리 테스트, 이벤트 전파 확인",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "크로스 플랫폼 알림 호환성 구현",
            "description": "다양한 플랫폼(웹, 모바일 웹, PWA)에서 알림 기능 호환성 확보",
            "dependencies": [
              2,
              3
            ],
            "details": "브라우저 호환성 검사 로직 구현, 기기별 대체 알림 메커니즘 개발, iOS 진동 API 제한 대응, 안드로이드/iOS 알림 권한 요청 처리, PWA 설치 시 알림 설정, 플랫폼별 폴백 UI 구현, 브라우저 호환성 테이블 작성",
            "status": "pending",
            "testStrategy": "다양한 브라우저 환경 테스트, iOS/안드로이드 호환성 검증, PWA 설치 환경 테스트, 알림 권한 거부 시나리오 테스트",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "알림 성능 최적화 및 배터리 효율성 개선",
            "description": "알림 시스템의 성능 최적화 및 모바일 기기 배터리 사용량 최소화",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "WebSocket 연결 유지 전략 최적화, 배터리 효율적인 폴링 간격 조정, 백그라운드/포그라운드 상태에 따른 연결 관리, 저전력 모드 감지 및 대응, 이벤트 배치 처리 구현, 불필요한 재연결 방지 로직, 네트워크 사용량 모니터링 및 최적화",
            "status": "pending",
            "testStrategy": "배터리 사용량 측정, 백그라운드/포그라운드 전환 테스트, 저전력 모드 대응 검증, 네트워크 사용량 분석",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "알림 관리 UI 구현",
            "description": "사용자가 알림 설정을 관리할 수 있는 인터페이스 개발",
            "dependencies": [
              2,
              3
            ],
            "details": "알림 설정 페이지 UI 디자인, 알림 유형별 켜기/끄기 기능, 알림음 선택 옵션, 진동 설정 옵션, 알림 볼륨 조절 기능, 알림 기록 조회 기능, 사용자 설정 저장 및 불러오기 로직, 설정 변경 시 실시간 적용",
            "status": "pending",
            "testStrategy": "설정 변경 저장 테스트, 설정 적용 확인, 알림 기록 조회 검증, 사용자 설정 유지 테스트",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "알림 시스템 통합 테스트 및 문서화",
            "description": "전체 알림 시스템의 통합 테스트 및 개발자 문서 작성",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9
            ],
            "details": "엔드투엔드 테스트 시나리오 작성, 통합 테스트 자동화 스크립트 개발, 성능 테스트 및 부하 테스트 수행, 에지 케이스 테스트, API 문서 작성, 개발자 가이드 작성, 트러블슈팅 가이드 작성, 알림 시스템 아키텍처 다이어그램 작성",
            "status": "pending",
            "testStrategy": "엔드투엔드 테스트 시나리오 실행, 부하 테스트 수행, 문서 정확성 검증, 트러블슈팅 가이드 유효성 확인",
            "parentId": "undefined"
          }
        ],
        "complexity": 9,
        "recommendedSubtasks": 5,
        "expansionPrompt": "실시간 알림 시스템을 Socket.io 클라이언트 설정 및 Zustand 통합, 고객 화면 알림 시스템(Toast, 진동, 화면 갱신), 주방 화면 알림 시스템(알림음, 카드 추가, 리스트 갱신), 재연결 로직 및 폴링 폴백, 크로스 플랫폼 호환성 및 성능 최적화로 분리하여 각 플랫폼별 알림 기능을 독립적으로 구현할 수 있도록 세분화해주세요."
      },
      {
        "id": "9",
        "title": "예외 처리 및 사용자 경험 개선",
        "description": "에러 핸들링, 로딩 상태, 브라우저 호환성 등 사용자 경험 개선",
        "details": "1. 에러 처리:\n   - API 호출 실패 시 Toast 에러 메시지\n   - 유효하지 않은 매장 ID → 에러 페이지\n   - 네트워크 오류 → 재시도 버튼\n   - WebSocket 연결 실패 → 경고 배너\n2. 로딩 상태 UI:\n   - Skeleton 컴포넌트 (메뉴 로딩 중)\n   - 버튼 Disabled 상태 (주문 처리 중)\n   - 스피너 및 로딩 인디케이터\n3. 브라우저 호환성:\n   - iOS Safari 14+, Chrome 90+, Samsung Internet 14+\n   - Progressive Enhancement (진동 API 미지원 시 소리로 대체)\n   - CSS Grid 미지원 시 Flexbox 폴백\n4. 성능 최적화:\n   - 이미지 최적화 (Next.js Image 컴포넌트)\n   - 코드 스플리팅 (Dynamic Import)\n   - 메뉴 데이터 캐싱\n5. 접근성 개선 (ARIA 라벨, 키보드 네비게이션)",
        "testStrategy": "주요 브라우저에서 기능 테스트, 에러 시나리오별 사용자 피드백 검증, Lighthouse 성능 점수 90+ 달성",
        "priority": "medium",
        "dependencies": [
          "8"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "API 에러 핸들링 및 사용자 피드백 시스템 구현",
            "description": "API 호출 실패, 네트워크 오류, WebSocket 연결 실패 등 다양한 에러 상황에 대한 처리 로직 구현",
            "dependencies": [],
            "details": "Toast 에러 메시지 컴포넌트 개발, 유효하지 않은 매장 ID 처리를 위한 에러 페이지 구현, 네트워크 오류 시 재시도 버튼 기능 추가, WebSocket 연결 실패 시 경고 배너 표시 로직 구현, 전역 에러 핸들링 시스템 구축",
            "status": "pending",
            "testStrategy": "다양한 에러 시나리오를 시뮬레이션하여 적절한 사용자 피드백이 제공되는지 검증",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "로딩 상태 UI 및 스켈레톤 컴포넌트 개발",
            "description": "데이터 로딩 중 사용자에게 시각적 피드백을 제공하는 다양한 로딩 상태 UI 구현",
            "dependencies": [],
            "details": "메뉴 로딩 중 표시할 Skeleton 컴포넌트 개발, 주문 처리 중 버튼 Disabled 상태 구현, 다양한 상황에 맞는 스피너 및 로딩 인디케이터 컴포넌트 제작, 로딩 상태 관리를 위한 전역 상태 설계",
            "status": "pending",
            "testStrategy": "다양한 네트워크 속도 환경에서 로딩 UI가 적절히 표시되는지 테스트, 사용자 경험 향상 여부 확인",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "브라우저 호환성 및 Progressive Enhancement 구현",
            "description": "다양한 브라우저와 디바이스에서 일관된 사용자 경험을 제공하기 위한 호환성 개선",
            "dependencies": [
              1,
              2
            ],
            "details": "iOS Safari 14+, Chrome 90+, Samsung Internet 14+ 호환성 테스트 및 대응, 진동 API 미지원 시 소리로 대체하는 Progressive Enhancement 구현, CSS Grid 미지원 브라우저를 위한 Flexbox 폴백 스타일 적용, 브라우저별 특이사항 대응",
            "status": "pending",
            "testStrategy": "BrowserStack을 활용한 다양한 브라우저 환경 테스트, 기능 저하 시나리오에서 대체 기능 동작 확인",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "이미지 최적화 및 Next.js Image 컴포넌트 적용",
            "description": "메뉴 이미지 및 UI 이미지에 Next.js Image 컴포넌트를 적용하여 로딩 성능 최적화",
            "dependencies": [],
            "details": "Next.js Image 컴포넌트로 기존 이미지 태그 교체, 이미지 포맷 최적화(WebP, AVIF), 반응형 이미지 사이즈 설정, 이미지 lazy loading 구현, 이미지 CDN 설정 및 최적화 전략 수립",
            "status": "pending",
            "testStrategy": "Lighthouse 성능 측정을 통한 이미지 최적화 효과 검증, 다양한 네트워크 환경에서 이미지 로딩 시간 측정",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "코드 스플리팅 및 Dynamic Import 적용",
            "description": "초기 로딩 시간 단축을 위한 코드 스플리팅 및 동적 임포트 전략 구현",
            "dependencies": [],
            "details": "Next.js의 dynamic import를 활용한 컴포넌트 지연 로딩 구현, 주요 페이지별 코드 스플리팅 전략 수립, 라우트 기반 코드 분할, 큰 라이브러리의 지연 로딩 적용, 번들 사이즈 분석 및 최적화",
            "status": "pending",
            "testStrategy": "Webpack Bundle Analyzer를 통한 번들 사이즈 분석, 초기 로딩 시간 측정 및 개선 효과 검증",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "메뉴 데이터 캐싱 및 상태 관리 최적화",
            "description": "메뉴 데이터의 효율적인 캐싱 및 상태 관리를 통한 성능 최적화",
            "dependencies": [
              4,
              5
            ],
            "details": "React Query를 활용한 메뉴 데이터 캐싱 구현, 캐시 무효화 전략 수립, 로컬 스토리지를 활용한 오프라인 지원, 상태 업데이트 최적화, 불필요한 리렌더링 방지, 메모이제이션 기법 적용",
            "status": "pending",
            "testStrategy": "캐싱 전후 API 호출 횟수 비교, 상태 업데이트 시 리렌더링 성능 측정, 오프라인 환경에서의 동작 테스트",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "접근성(A11Y) 개선 및 ARIA 속성 적용",
            "description": "스크린 리더 및 키보드 사용자를 위한 접근성 개선 작업 수행",
            "dependencies": [
              2,
              3
            ],
            "details": "모든 상호작용 요소에 ARIA 라벨 추가, 키보드 네비게이션 지원 구현, 색상 대비 개선, 스크린 리더 호환성 테스트, 접근성 트리 검토 및 개선, 포커스 관리 최적화, 접근성 체크리스트 작성 및 적용",
            "status": "pending",
            "testStrategy": "axe-core를 활용한 자동화된 접근성 테스트, 스크린 리더로 전체 사용자 흐름 테스트, 키보드만으로 모든 기능 사용 가능 여부 확인",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "사용자 경험 테스트 및 피드백 반영",
            "description": "실제 사용자를 대상으로 한 사용성 테스트 진행 및 피드백을 통한 UX 개선",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6,
              7
            ],
            "details": "다양한 사용자 그룹을 대상으로 사용성 테스트 진행, 피드백 수집 및 분석, 주요 UX 문제점 식별 및 개선 우선순위 설정, A/B 테스트 설계 및 실행, 사용자 행동 분석을 통한 UI 최적화, 최종 UX 개선 사항 적용 및 검증",
            "status": "pending",
            "testStrategy": "사용자 테스트 세션 녹화 및 분석, 핵심 사용자 경로에서의 완료율 측정, 사용자 만족도 설문 조사",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "사용자 경험 개선을 에러 핸들링 및 사용자 피드백 시스템, 로딩 상태 및 스켈레톤 UI 구현, 브라우저 호환성 및 Progressive Enhancement, 성능 최적화 및 접근성 개선으로 분리하여 각 UX 측면을 독립적으로 개선할 수 있도록 세분화해주세요."
      },
      {
        "id": "10",
        "title": "배포 및 CI/CD 파이프라인 구축",
        "description": "프로덕션 배포를 위한 인프라 설정 및 자동화 파이프라인 구축",
        "details": "1. AWS EC2 설정:\n   - Ubuntu 22.04 인스턴스 생성 (t3.small)\n   - Docker 및 Docker Compose 설치\n   - Nginx 리버스 프록시 설정\n   - SSL 인증서 설정 (Let's Encrypt)\n2. Docker 설정:\n   ```dockerfile\n   FROM node:18-alpine\n   WORKDIR /app\n   COPY package*.json ./\n   RUN npm ci --only=production\n   COPY . .\n   EXPOSE 3000\n   CMD [\"npm\", \"start\"]\n   ```\n3. GitHub Actions CI/CD:\n   - 코드 푸시 시 자동 빌드\n   - Docker 이미지 GHCR 푸시\n   - EC2 SSH 배포 자동화\n4. Vercel 프론트엔드 배포:\n   - Next.js 앱 자동 배포\n   - 환경변수 설정\n   - 도메인 연결\n5. 모니터링 설정:\n   - CloudWatch 알람 (CPU, 메모리)\n   - Health Check 엔드포인트\n   - Sentry 에러 트래킹\n6. E2E 테스트 (Playwright):\n   - 고객 주문 → 주방 처리 → 호출 전체 플로우",
        "testStrategy": "프로덕션 환경에서 전체 시스템 동작 검증, 자동 배포 파이프라인 테스트, 모니터링 알람 동작 확인",
        "priority": "medium",
        "dependencies": [
          "9"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "AWS EC2 인스턴스 설정 및 기본 환경 구성",
            "description": "Ubuntu 22.04 EC2 인스턴스를 생성하고 기본 서버 환경을 구성합니다.",
            "dependencies": [],
            "details": "t3.small 인스턴스 생성, 보안 그룹 설정(SSH, HTTP, HTTPS 포트 오픈), 탄력적 IP 할당, 서버 업데이트 및 기본 패키지 설치, SSH 키 관리 설정, 방화벽 구성",
            "status": "pending",
            "testStrategy": "인스턴스 SSH 접속 테스트, 네트워크 연결 확인, 기본 패키지 설치 검증",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Docker 및 Docker Compose 설치 및 구성",
            "description": "EC2 인스턴스에 Docker 환경을 설정하고 컨테이너 관리를 위한 Docker Compose를 구성합니다.",
            "dependencies": [
              1
            ],
            "details": "Docker 설치, Docker Compose 설치, Docker 사용자 권한 설정, Docker 네트워크 구성, Docker 자동 시작 설정, Docker 이미지 풀링 테스트, docker-compose.yml 파일 작성",
            "status": "pending",
            "testStrategy": "Docker 버전 확인, 테스트 컨테이너 실행, Docker Compose 기능 검증",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Nginx 리버스 프록시 및 SSL 인증서 설정",
            "description": "Nginx를 리버스 프록시로 설정하고 Let's Encrypt를 통한 SSL 인증서를 구성합니다.",
            "dependencies": [
              2
            ],
            "details": "Nginx Docker 컨테이너 설정, 리버스 프록시 설정 파일 구성, Let's Encrypt Certbot 설치, SSL 인증서 발급 및 적용, 인증서 자동 갱신 설정, HTTP에서 HTTPS로 리다이렉션 설정",
            "status": "pending",
            "testStrategy": "HTTPS 연결 테스트, SSL 인증서 유효성 확인, 리다이렉션 동작 검증",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "백엔드 Dockerfile 및 컨테이너 구성",
            "description": "Node.js 백엔드 애플리케이션을 위한 Dockerfile 작성 및 컨테이너 설정을 구성합니다.",
            "dependencies": [
              2
            ],
            "details": "Dockerfile 작성(Node.js 18 Alpine 기반), .dockerignore 파일 설정, 멀티 스테이지 빌드 최적화, 환경 변수 설정, 볼륨 마운트 구성, 컨테이너 헬스체크 설정, Docker Compose 서비스 정의",
            "status": "pending",
            "testStrategy": "로컬 Docker 빌드 테스트, 컨테이너 실행 및 API 응답 확인, 환경 변수 주입 테스트",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "GitHub Actions CI 파이프라인 구축",
            "description": "GitHub Actions를 사용하여 코드 푸시 시 자동 빌드 및 테스트를 수행하는 CI 파이프라인을 구축합니다.",
            "dependencies": [
              4
            ],
            "details": "GitHub Actions workflow 파일 작성(.github/workflows/ci.yml), Node.js 빌드 및 테스트 단계 구성, ESLint 및 TypeScript 검사 추가, 테스트 실행 설정, Docker 이미지 빌드 및 GHCR 푸시 설정, 캐싱 최적화",
            "status": "pending",
            "testStrategy": "PR 생성 시 CI 파이프라인 실행 테스트, 빌드 실패 시나리오 테스트, 이미지 푸시 검증",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "GitHub Actions CD 파이프라인 구축",
            "description": "GitHub Actions를 사용하여 EC2 인스턴스에 자동 배포하는 CD 파이프라인을 구축합니다.",
            "dependencies": [
              3,
              5
            ],
            "details": "GitHub Actions workflow 파일 작성(.github/workflows/cd.yml), GitHub Secrets 설정(SSH 키, 서버 정보), SSH를 통한 EC2 배포 스크립트 작성, Docker Compose 원격 실행, 롤백 메커니즘 구현, 배포 알림 설정",
            "status": "pending",
            "testStrategy": "메인 브랜치 푸시 시 자동 배포 테스트, 배포 실패 시 롤백 테스트, 배포 후 서비스 가용성 확인",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Vercel 프론트엔드 배포 자동화",
            "description": "Next.js 프론트엔드 애플리케이션을 Vercel에 자동 배포하는 시스템을 구축합니다.",
            "dependencies": [
              6
            ],
            "details": "Vercel 프로젝트 생성, GitHub 저장소 연결, 빌드 설정 구성, 환경 변수 설정(백엔드 API URL 등), 커스텀 도메인 연결, 배포 웹훅 설정, 프리뷰 배포 설정",
            "status": "pending",
            "testStrategy": "PR 생성 시 프리뷰 배포 테스트, 프로덕션 배포 검증, 환경 변수 적용 확인",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "서버 모니터링 및 로깅 시스템 구축",
            "description": "AWS CloudWatch와 Sentry를 사용하여 서버 모니터링 및 에러 트래킹 시스템을 구축합니다.",
            "dependencies": [
              6
            ],
            "details": "CloudWatch 에이전트 설치, CPU/메모리/디스크 알람 설정, 로그 수집 설정, Sentry SDK 통합, 에러 알림 설정, 성능 모니터링 구성, 대시보드 생성, 알림 채널 설정(Slack/이메일)",
            "status": "pending",
            "testStrategy": "테스트 알람 트리거, 에러 로깅 테스트, 알림 전달 확인, 대시보드 데이터 표시 검증",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "헬스체크 및 자동 복구 시스템 구현",
            "description": "서비스 헬스체크 엔드포인트를 구현하고 자동 복구 메커니즘을 설정합니다.",
            "dependencies": [
              6,
              8
            ],
            "details": "API 헬스체크 엔드포인트 구현, Docker 컨테이너 헬스체크 설정, 자동 재시작 정책 구성, 데드락 감지 로직 추가, 데이터베이스 연결 상태 모니터링, 외부 서비스 의존성 체크, 정기적 헬스체크 크론잡 설정",
            "status": "pending",
            "testStrategy": "서비스 강제 종료 후 자동 복구 테스트, 데이터베이스 연결 끊김 시나리오 테스트, 헬스체크 응답 검증",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "E2E 테스트 및 프로덕션 검증 시스템 구축",
            "description": "Playwright를 사용하여 전체 서비스 흐름을 검증하는 E2E 테스트 시스템을 구축합니다.",
            "dependencies": [
              7,
              9
            ],
            "details": "Playwright 설정, 고객 주문 → 주방 처리 → 호출 전체 플로우 테스트 시나리오 작성, CI/CD 파이프라인에 E2E 테스트 통합, 테스트 보고서 생성, 스크린샷 및 비디오 캡처 설정, 프로덕션 환경 검증 스크립트 작성",
            "status": "pending",
            "testStrategy": "전체 주문 프로세스 E2E 테스트, 다양한 브라우저 환경 테스트, 배포 후 자동 검증 실행",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 5,
        "expansionPrompt": "배포 파이프라인을 AWS EC2 인프라 설정 및 Docker 환경 구성, GitHub Actions CI/CD 파이프라인 구축, Vercel 프론트엔드 배포 자동화, 모니터링 및 헬스체크 시스템 구축, E2E 테스트 및 프로덕션 검증으로 분리하여 각 배포 단계를 독립적으로 구성하고 검증할 수 있도록 세분화해주세요."
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-01-18T12:46:11.648Z",
      "taskCount": 10,
      "completedCount": 3,
      "tags": [
        "master"
      ]
    }
  }
}